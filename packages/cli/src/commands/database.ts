import { Command } from 'commander';
import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';
import * as prettier from 'prettier';
import chalk from 'chalk';
import ora from 'ora';

const KyselyTypeMapping: Record<string, string> = {
  // Number types
  integer: 'number',
  int2: 'number',
  int4: 'number',
  int8: 'number',
  smallint: 'number',
  bigint: 'number',
  real: 'number',
  'double precision': 'number',
  float4: 'number',
  float8: 'number',
  decimal: 'number',
  numeric: 'number',
  serial: 'number',
  bigserial: 'number',

  // String types
  varchar: 'string',
  char: 'string',
  text: 'string',
  uuid: 'string',
  date: 'string',
  time: 'string',
  timetz: 'string',
  timestamp: 'string',
  timestamptz: 'string',
  datetime: 'string',
  blob: 'string',
  varbinary: 'string',

  // Boolean
  boolean: 'boolean',

  // JSON/Any
  json: 'any',
  jsonb: 'any',
  binary: 'any',
  bytea: 'any',
};

// Default mapping for unknown types
const DEFAULT_TYPE = 'any';

interface ColumnInfo {
  name: string;
  defaultValue: any;
  dataType: string;
  isNullable: boolean;
  isPrimaryKey: boolean;
  hasAutoIncrement: boolean;
  hasDefaultValue: boolean;
  foreignKeyReference?: {
    table: string;
    column: string;
  };
}

interface ForeignKeyInfo {
  table: string;
  column: string;
  foreignTable: string;
  foreignColumn: string;
  constraintName?: string;
  onDelete?: string;
  onUpdate?: string;
}

interface TableInfo {
  columns: ColumnInfo[];
  foreignKeys: ForeignKeyInfo[];
  //indexes: any;
}

interface DatabaseSchema {
  [tableName: string]: TableInfo;
}

import { showBanner, confirmAction } from '../utils/ui.js';

export const databaseCommand = new Command('database')
  .description('Database management commands')
  .requiredOption('--url <url>', 'URL to the ForgeBase schema endpoint')
  .requiredOption('--output <path>', 'Path to save the generated schema file')
  .option('-y, --yes', 'Skip confirmation prompt')
  .action(async (options) => {
    showBanner(
      'Database Schema Generator',
      'Generates TypeScript definitions from your running database.',
    );

    const confirmed = await confirmAction(
      `Do you want to generate the schema from ${chalk.bold(options.url)} to ${chalk.bold(options.output)}?`,
      options.yes,
    );

    if (!confirmed) {
      console.log(chalk.yellow('Operation cancelled.'));
      return;
    }

    const spinner = ora('Fetching database schema...').start();
    try {
      // 1. Fetch Schema
      const response = await axios.get<DatabaseSchema>(options.url);
      const schema = response.data;

      if (!schema || typeof schema !== 'object') {
        throw new Error('Invalid schema response from server');
      }

      spinner.text = 'Generating TypeScript definitions...';

      // 2. Generate TypeScript Interfaces
      const lines: string[] = [];
      const tableNames: string[] = [];

      // Add file header
      lines.push('/**');
      lines.push(' * This file was auto-generated by @forgebase/cli.');
      lines.push(' * Do not modify this file manually.');
      lines.push(' */');
      lines.push('');

      for (const [tableName, tableInfo] of Object.entries(schema)) {
        const interfaceName = toPascalCase(tableName);
        tableNames.push(tableName); // Keep original table name for Schema interface keys

        // Generate the main interface (for reading/selecting)
        lines.push(`export interface ${interfaceName} {`);

        for (const col of tableInfo.columns) {
          // Map type
          let tsType =
            KyselyTypeMapping[col.dataType.toLowerCase()] || DEFAULT_TYPE;

          // Handle nullability
          if (col.isNullable) {
            lines.push(`  ${col.name}?: ${tsType};`);
          } else {
            lines.push(`  ${col.name}: ${tsType};`);
          }
        }

        lines.push('}');
        lines.push('');

        // Generate the Create interface (for inserting/creating)
        lines.push(`export interface ${interfaceName}Create {`);

        for (const col of tableInfo.columns) {
          // Map type
          let tsType =
            KyselyTypeMapping[col.dataType.toLowerCase()] || DEFAULT_TYPE;

          if (col.hasDefaultValue || col.hasAutoIncrement || col.isNullable) {
            lines.push(`  ${col.name}?: ${tsType};`);
          } else {
            lines.push(`  ${col.name}: ${tsType};`);
          }
        }

        lines.push('}');
        lines.push('');
      }

      // 3. Generate Schema Interface
      lines.push('export interface Schema {');
      for (const tableName of tableNames) {
        // Map table name to interface name
        // e.g. "users" -> "users: User" (assuming User interface is generated)
        // But commonly tables are plural, interfaces are singular/pascal.
        // Let's use the generated interface name.
        const interfaceName = toPascalCase(tableName);
        lines.push(`  ${tableName}: ${interfaceName};`);
      }
      lines.push('}');
      lines.push('');

      lines.push('export interface CreateSchema {');
      for (const tableName of tableNames) {
        const interfaceName = toPascalCase(tableName);
        lines.push(`  ${tableName}: ${interfaceName}Create;`);
      }
      lines.push('}');
      lines.push('');

      // 4. Format with Prettier
      const rawContent = lines.join('\n');
      const formattedContent = await prettier.format(rawContent, {
        parser: 'typescript',
        singleQuote: true,
      });

      // 5. Write to file
      const outputPath = path.resolve(process.cwd(), options.output);
      const outputDir = path.dirname(outputPath);

      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      fs.writeFileSync(outputPath, formattedContent);

      spinner.succeed(chalk.green(`Schema generated successfully!`));

      console.log('');
      console.log(chalk.cyan('  → ') + chalk.bold('Source:   ') + options.url);
      console.log(chalk.cyan('  → ') + chalk.bold('Output:   ') + outputPath);
      console.log(
        chalk.cyan('  → ') + chalk.bold('Tables:   ') + tableNames.length,
      );
      console.log('');
      console.log(chalk.gray('  You can now use this schema with the SDK:'));
      console.log(chalk.blue('  const db = new DatabaseSDK<Schema>(...);'));
      console.log('');
    } catch (error: any) {
      spinner.fail(chalk.red('Failed to generate schema'));
      console.error(chalk.red(error.message));
      if (axios.isAxiosError(error)) {
        console.error(
          chalk.red(
            `Status: ${error.response?.status} ${error.response?.statusText}`,
          ),
        );
      }
      process.exit(1);
    }
  });

function toPascalCase(str: string): string {
  // Handle snake_case, kebab-case, etc.
  // e.g. user_profiles -> UserProfiles
  return (
    str
      .match(/[a-z0-9]+/gi)
      ?.map(
        (word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase(),
      )
      .join('') || str
  );
}
